\section{Тест производительности}
В этом разделе сравнивается время работы собственной реализации сортировки подсчётом
и стандартной стабильной сортировки C++ (\texttt{std::stable\_sort}).
Тестовые данные генерируются скриптом \texttt{generator.py}: ключи равномерно распределены
в диапазоне $[0, 65535]$, значение -- строка длиной от 1 до 64 знаков.
Для каждого размера входа выполнено 5 независимых запусков, в таблице приведены медианные значения
времени (в микросекундах) и отношение времени \texttt{STL/Counting}.

Команда запуска:
\begin{alltt}
$ python3 generator.py > b.txt
$ ./benchmark.out < b.txt
\end{alltt}

\textbf{Сводная таблица результатов:}
\begin{longtable}{|r|r|r|r|}
\hline
\rowcolor{lightgray}
$n$ & Counting, \texttt{us} & STL, \texttt{us} & STL/Counting \\
\hline
100 & 39 & 3 & $0.08\times$ \\
\hline
10\,000 & 384 & 442 & $1.15\times$ \\
\hline
100\,000 & 3430 & 7092 & $2.07\times$ \\
\hline
1\,000\,000 & 49307 & 111407 & $2.26\times$ \\
\hline
10\,000\,000 & 528712 & 1907158 & $3.61\times$ \\
\hline
\end{longtable}

На малом объёме данных ($n=100$) сортировка подсчётом ожидаемо проигрывает:
затраты на инициализацию массива счётчиков размера $k=65536$ уже есть, а полезной работы ещё мало.
Начиная с $n=10^4$ ситуация меняется, и сортировка подсчётом становится быстрее.
В диапазоне от $10^5$ до $10^7$ преимущество растёт от $2.07\times$ до $3.61\times$,
что согласуется с теорией: при фиксированном диапазоне ключей алгоритм работает за $O(n + k)$,
тогда как \texttt{std::stable\_sort} требует $O(n \log n)$ сравнений.

\pagebreak
